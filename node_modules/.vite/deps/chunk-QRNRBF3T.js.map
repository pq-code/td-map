{
  "version": 3,
  "sources": ["../../.pnpm/ol@8.1.0/node_modules/ol/Tile.js", "../../.pnpm/ol@8.1.0/node_modules/ol/ImageState.js", "../../.pnpm/ol@8.1.0/node_modules/ol/Image.js", "../../.pnpm/ol@8.1.0/node_modules/ol/ImageTile.js", "../../.pnpm/ol@8.1.0/node_modules/ol/TileRange.js"],
  "sourcesContent": ["/**\n * @module ol/Tile\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport TileState from './TileState.js';\nimport {abstract} from './util.js';\nimport {easeIn} from './easing.js';\n\n/**\n * A function that takes an {@link module:ol/Tile~Tile} for the tile and a\n * `{string}` for the url as arguments. The default is\n * ```js\n * source.setTileLoadFunction(function(tile, src) {\n *   tile.getImage().src = src;\n * });\n * ```\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n * error handling:\n *\n * ```js\n * import TileState from 'ol/TileState.js';\n *\n * source.setTileLoadFunction(function(tile, src) {\n *   const xhr = new XMLHttpRequest();\n *   xhr.responseType = 'blob';\n *   xhr.addEventListener('loadend', function (evt) {\n *     const data = this.response;\n *     if (data !== undefined) {\n *       tile.getImage().src = URL.createObjectURL(data);\n *     } else {\n *       tile.setState(TileState.ERROR);\n *     }\n *   });\n *   xhr.addEventListener('error', function () {\n *     tile.setState(TileState.ERROR);\n *   });\n *   xhr.open('GET', src);\n *   xhr.send();\n * });\n * ```\n *\n * @typedef {function(Tile, string): void} LoadFunction\n * @api\n */\n\n/**\n * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get\n * the url that provides a tile for a given tile coordinate.\n *\n * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile\n * coordinate, a `{number}` representing the pixel ratio and a\n * {@link module:ol/proj/Projection~Projection} for the projection  as arguments\n * and returns a `{string}` representing the tile URL, or undefined if no tile\n * should be requested for the passed tile coordinate.\n *\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\n * @api\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @api\n */\n\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @abstract\n */\nclass Tile extends EventTarget {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n    this.tileCoord = tileCoord;\n\n    /**\n     * @protected\n     * @type {import(\"./TileState.js\").default}\n     */\n    this.state = state;\n\n    /**\n     * An \"interim\" tile for this tile. The interim tile may be used while this\n     * one is loading, for \"smooth\" transitions when changing params/dimensions\n     * on the source.\n     * @type {Tile}\n     */\n    this.interimTile = null;\n\n    /**\n     * A key assigned to the tile. This is used by the tile source to determine\n     * if this tile can effectively be used, or if a new tile should be created\n     * and this one be used as an interim tile for this new tile.\n     * @type {string}\n     */\n    this.key = '';\n\n    /**\n     * The duration for the opacity transition.\n     * @type {number}\n     */\n    this.transition_ =\n      options.transition === undefined ? 250 : options.transition;\n\n    /**\n     * Lookup of start times for rendering transitions.  If the start time is\n     * equal to -1, the transition is complete.\n     * @type {Object<string, number>}\n     */\n    this.transitionStarts_ = {};\n\n    /**\n     * @type {boolean}\n     */\n    this.interpolate = !!options.interpolate;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * Called by the tile cache when the tile is removed from the cache due to expiry\n   */\n  release() {\n    if (this.state === TileState.ERROR) {\n      // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`\n      this.setState(TileState.EMPTY);\n    }\n  }\n\n  /**\n   * @return {string} Key.\n   */\n  getKey() {\n    return this.key + '/' + this.tileCoord;\n  }\n\n  /**\n   * Get the interim tile most suitable for rendering using the chain of interim\n   * tiles. This corresponds to the  most recent tile that has been loaded, if no\n   * such tile exists, the original tile is returned.\n   * @return {!Tile} Best tile for rendering.\n   */\n  getInterimTile() {\n    if (!this.interimTile) {\n      //empty chain\n      return this;\n    }\n    let tile = this.interimTile;\n\n    // find the first loaded tile and return it. Since the chain is sorted in\n    // decreasing order of creation time, there is no need to search the remainder\n    // of the list (all those tiles correspond to older requests and will be\n    // cleaned up by refreshInterimChain)\n    do {\n      if (tile.getState() == TileState.LOADED) {\n        // Show tile immediately instead of fading it in after loading, because\n        // the interim tile is in place already\n        this.transition_ = 0;\n        return tile;\n      }\n      tile = tile.interimTile;\n    } while (tile);\n\n    // we can not find a better tile\n    return this;\n  }\n\n  /**\n   * Goes through the chain of interim tiles and discards sections of the chain\n   * that are no longer relevant.\n   */\n  refreshInterimChain() {\n    if (!this.interimTile) {\n      return;\n    }\n\n    let tile = this.interimTile;\n\n    /**\n     * @type {Tile}\n     */\n    let prev = this;\n\n    do {\n      if (tile.getState() == TileState.LOADED) {\n        //we have a loaded tile, we can discard the rest of the list\n        //we would could abort any LOADING tile request\n        //older than this tile (i.e. any LOADING tile following this entry in the chain)\n        tile.interimTile = null;\n        break;\n      } else if (tile.getState() == TileState.LOADING) {\n        //keep this LOADING tile any loaded tiles later in the chain are\n        //older than this tile, so we're still interested in the request\n        prev = tile;\n      } else if (tile.getState() == TileState.IDLE) {\n        //the head of the list is the most current tile, we don't need\n        //to start any other requests for this chain\n        prev.interimTile = tile.interimTile;\n      } else {\n        prev = tile;\n      }\n      tile = prev.interimTile;\n    } while (tile);\n  }\n\n  /**\n   * Get the tile coordinate for this tile.\n   * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\n   * @api\n   */\n  getTileCoord() {\n    return this.tileCoord;\n  }\n\n  /**\n   * @return {import(\"./TileState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n   * the tile queue and will block other requests.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @api\n   */\n  setState(state) {\n    if (this.state !== TileState.ERROR && this.state > state) {\n      throw new Error('Tile load sequence violation');\n    }\n    this.state = state;\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @abstract\n   * @api\n   */\n  load() {\n    abstract();\n  }\n\n  /**\n   * Get the alpha value for rendering.\n   * @param {string} id An id for the renderer.\n   * @param {number} time The render frame time.\n   * @return {number} A number between 0 and 1.\n   */\n  getAlpha(id, time) {\n    if (!this.transition_) {\n      return 1;\n    }\n\n    let start = this.transitionStarts_[id];\n    if (!start) {\n      start = time;\n      this.transitionStarts_[id] = start;\n    } else if (start === -1) {\n      return 1;\n    }\n\n    const delta = time - start + 1000 / 60; // avoid rendering at 0\n    if (delta >= this.transition_) {\n      return 1;\n    }\n    return easeIn(delta / this.transition_);\n  }\n\n  /**\n   * Determine if a tile is in an alpha transition.  A tile is considered in\n   * transition if tile.getAlpha() has not yet been called or has been called\n   * and returned 1.\n   * @param {string} id An id for the renderer.\n   * @return {boolean} The tile is in transition.\n   */\n  inTransition(id) {\n    if (!this.transition_) {\n      return false;\n    }\n    return this.transitionStarts_[id] !== -1;\n  }\n\n  /**\n   * Mark a transition as complete.\n   * @param {string} id An id for the renderer.\n   */\n  endTransition(id) {\n    if (this.transition_) {\n      this.transitionStarts_[id] = -1;\n    }\n  }\n}\n\nexport default Tile;\n", "/**\n * @module ol/ImageState\n */\n\n/**\n * @enum {number}\n */\nexport default {\n  IDLE: 0,\n  LOADING: 1,\n  LOADED: 2,\n  ERROR: 3,\n  EMPTY: 4,\n};\n", "/**\n * @module ol/Image\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport ImageState from './ImageState.js';\nimport {CREATE_IMAGE_BITMAP, IMAGE_DECODE} from './has.js';\nimport {listenOnce, unlistenByKey} from './events.js';\nimport {toPromise} from './functions.js';\n\n/**\n * A function that takes an {@link module:ol/Image~ImageWrapper} for the image and a\n * `{string}` for the src as arguments. It is supposed to make it so the\n * underlying image {@link module:ol/Image~ImageWrapper#getImage} is assigned the\n * content specified by the src. If not specified, the default is\n *\n *     function(image, src) {\n *       image.getImage().src = src;\n *     }\n *\n * Providing a custom `imageLoadFunction` can be useful to load images with\n * post requests or - in general - through XHR requests, where the src of the\n * image element would be set to a data URI when the content is loaded.\n *\n * @typedef {function(import(\"./Image.js\").default, string): void} LoadFunction\n * @api\n */\n\n/**\n * @typedef {Object} ImageObject\n * @property {import(\"./extent.js\").Extent} [extent] Extent, if different from the requested one.\n * @property {import(\"./resolution.js\").ResolutionLike} [resolution] Resolution, if different from the requested one.\n * When x and y resolution are different, use the array type (`[xResolution, yResolution]`).\n * @property {number} [pixelRatio] Pixel ratio, if different from the requested one.\n * @property {import('./DataTile.js').ImageLike} image Image.\n */\n\n/**\n * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.\n * For images that cover any extent and resolution (static images), the loader function should not accept\n * any arguments. The function returns an {@link import(\"./DataTile.js\").ImageLike image}, an\n * {@link import(\"./Image.js\").ImageObject image object}, or a promise for the same.\n * For loaders that generate images, the promise should not resolve until the image is loaded.\n * If the returned image does not match the extent, resolution or pixel ratio passed to the loader,\n * it has to return an {@link import(\"./Image.js\").ImageObject image object} with the `image` and the\n * correct `extent`, `resolution` and `pixelRatio`.\n *\n * @typedef {function(import(\"./extent.js\").Extent, number, number, (function(HTMLImageElement, string): void)=): import(\"./DataTile.js\").ImageLike|ImageObject|Promise<import(\"./DataTile.js\").ImageLike|ImageObject>} Loader\n * @api\n */\n\n/**\n * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.\n * The function returns a promise for an  {@link import(\"./Image.js\").ImageObject image object}.\n *\n * @typedef {function(import(\"./extent.js\").Extent, number, number, (function(HTMLImageElement, string): void)=): import(\"./DataTile.js\").ImageLike|ImageObject|Promise<import(\"./DataTile.js\").ImageLike|ImageObject>} ImageObjectPromiseLoader\n */\n\nclass ImageWrapper extends EventTarget {\n  /**\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y\n   * resolution will be assumed.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"./ImageState.js\").default|import(\"./Image.js\").Loader} stateOrLoader State.\n   */\n  constructor(extent, resolution, pixelRatio, stateOrLoader) {\n    super();\n\n    /**\n     * @protected\n     * @type {import(\"./extent.js\").Extent}\n     */\n    this.extent = extent;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @protected\n     * @type {number|Array<number>|undefined}\n     */\n    this.resolution = resolution;\n\n    /**\n     * @protected\n     * @type {import(\"./ImageState.js\").default}\n     */\n    this.state =\n      typeof stateOrLoader === 'function' ? ImageState.IDLE : stateOrLoader;\n\n    /**\n     * @private\n     * @type {import('./DataTile.js').ImageLike|null}\n     */\n    this.image_ = null;\n\n    /**\n     * @protected\n     * @type {import(\"./Image.js\").Loader}\n     */\n    this.loader = typeof stateOrLoader === 'function' ? stateOrLoader : null;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * @return {import(\"./extent.js\").Extent} Extent.\n   */\n  getExtent() {\n    return this.extent;\n  }\n\n  /**\n   * @return {import('./DataTile.js').ImageLike} Image.\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * @return {number} PixelRatio.\n   */\n  getPixelRatio() {\n    return this.pixelRatio_;\n  }\n\n  /**\n   * @return {number|Array<number>} Resolution.\n   */\n  getResolution() {\n    return /** @type {number} */ (this.resolution);\n  }\n\n  /**\n   * @return {import(\"./ImageState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == ImageState.IDLE) {\n      if (this.loader) {\n        this.state = ImageState.LOADING;\n        this.changed();\n        const resolution = this.getResolution();\n        const requestResolution = Array.isArray(resolution)\n          ? resolution[0]\n          : resolution;\n        toPromise(() =>\n          this.loader(this.getExtent(), requestResolution, this.getPixelRatio())\n        )\n          .then((image) => {\n            if ('image' in image) {\n              this.image_ = image.image;\n            }\n            if ('extent' in image) {\n              this.extent = image.extent;\n            }\n            if ('resolution' in image) {\n              this.resolution = image.resolution;\n            }\n            if ('pixelRatio' in image) {\n              this.pixelRatio_ = image.pixelRatio;\n            }\n            if (\n              image instanceof HTMLImageElement ||\n              image instanceof ImageBitmap ||\n              image instanceof HTMLCanvasElement ||\n              image instanceof HTMLVideoElement\n            ) {\n              this.image_ = image;\n            }\n            this.state = ImageState.LOADED;\n          })\n          .catch((error) => {\n            this.state = ImageState.ERROR;\n            console.error(error); // eslint-disable-line no-console\n          })\n          .finally(() => this.changed());\n      }\n    }\n  }\n\n  /**\n   * @param {import('./DataTile.js').ImageLike} image The image.\n   */\n  setImage(image) {\n    this.image_ = image;\n  }\n\n  /**\n   * @param {number|Array<number>} resolution Resolution.\n   */\n  setResolution(resolution) {\n    this.resolution = resolution;\n  }\n}\n\n/**\n * @param {import('./DataTile.js').ImageLike} image Image element.\n * @param {function():any} loadHandler Load callback function.\n * @param {function():any} errorHandler Error callback function.\n * @return {function():void} Callback to stop listening.\n */\nexport function listenImage(image, loadHandler, errorHandler) {\n  const img = /** @type {HTMLImageElement} */ (image);\n  let listening = true;\n  let decoding = false;\n  let loaded = false;\n\n  const listenerKeys = [\n    listenOnce(img, EventType.LOAD, function () {\n      loaded = true;\n      if (!decoding) {\n        loadHandler();\n      }\n    }),\n  ];\n\n  if (img.src && IMAGE_DECODE) {\n    decoding = true;\n    img\n      .decode()\n      .then(function () {\n        if (listening) {\n          loadHandler();\n        }\n      })\n      .catch(function (error) {\n        if (listening) {\n          if (loaded) {\n            loadHandler();\n          } else {\n            errorHandler();\n          }\n        }\n      });\n  } else {\n    listenerKeys.push(listenOnce(img, EventType.ERROR, errorHandler));\n  }\n\n  return function unlisten() {\n    listening = false;\n    listenerKeys.forEach(unlistenByKey);\n  };\n}\n\n/**\n * Loads an image.\n * @param {HTMLImageElement} image Image, not yet loaded.\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\n * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.\n * @api\n */\nexport function load(image, src) {\n  return new Promise((resolve, reject) => {\n    function handleLoad() {\n      unlisten();\n      resolve(image);\n    }\n    function handleError() {\n      unlisten();\n      reject(new Error('Image load error'));\n    }\n    function unlisten() {\n      image.removeEventListener('load', handleLoad);\n      image.removeEventListener('error', handleError);\n    }\n    image.addEventListener('load', handleLoad);\n    image.addEventListener('error', handleError);\n    if (src) {\n      image.src = src;\n    }\n  });\n}\n\n/**\n * @param {HTMLImageElement} image Image, not yet loaded.\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\n * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.\n */\nexport function decodeFallback(image, src) {\n  if (src) {\n    image.src = src;\n  }\n  return IMAGE_DECODE\n    ? new Promise((resolve, reject) =>\n        image.decode().then(() => resolve(image), reject)\n      )\n    : load(image);\n}\n\n/**\n * Loads an image and decodes it to an `ImageBitmap` if `createImageBitmap()` is supported. Returns\n * the loaded image otherwise.\n * @param {HTMLImageElement} image Image, not yet loaded.\n * @param {string} [src] `src` attribute of the image. Optional, not required if already present.\n * @return {Promise<ImageBitmap|HTMLImageElement>} Promise resolving to an `ImageBitmap` or an\n * `HTMLImageElement` if `createImageBitmap()` is not supported.\n * @api\n */\nexport function decode(image, src) {\n  if (src) {\n    image.src = src;\n  }\n  return IMAGE_DECODE && CREATE_IMAGE_BITMAP\n    ? image.decode().then(() => createImageBitmap(image))\n    : decodeFallback(image);\n}\n\nexport default ImageWrapper;\n", "/**\n * @module ol/ImageTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\nimport {listenImage} from './Image.js';\n\nclass ImageTile extends Tile {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"./Tile.js\").Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {\n    super(tileCoord, state, options);\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ = crossOrigin;\n\n    /**\n     * Image URI\n     *\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    this.key = src;\n\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n    this.image_ = new Image();\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n\n    /**\n     * @private\n     * @type {?function():void}\n     */\n    this.unlisten_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction_ = tileLoadFunction;\n  }\n\n  /**\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @api\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\n   * @param {HTMLCanvasElement|HTMLImageElement} element Element.\n   */\n  setImage(element) {\n    this.image_ = element;\n    this.state = TileState.LOADED;\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n  handleImageError_() {\n    this.state = TileState.ERROR;\n    this.unlistenImage_();\n    this.image_ = getBlankImage();\n    this.changed();\n  }\n\n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n  handleImageLoad_() {\n    const image = /** @type {HTMLImageElement} */ (this.image_);\n    if (image.naturalWidth && image.naturalHeight) {\n      this.state = TileState.LOADED;\n    } else {\n      this.state = TileState.EMPTY;\n    }\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   *\n   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`\n   * that checks for error status codes and reloads only when the status code is\n   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been\n   * made already:\n   *\n   * ```js\n   * const retryCodes = [408, 429, 500, 502, 503, 504];\n   * const retries = {};\n   * source.setTileLoadFunction((tile, src) => {\n   *   const image = tile.getImage();\n   *   fetch(src)\n   *     .then((response) => {\n   *       if (retryCodes.includes(response.status)) {\n   *         retries[src] = (retries[src] || 0) + 1;\n   *         if (retries[src] <= 3) {\n   *           setTimeout(() => tile.load(), retries[src] * 1000);\n   *         }\n   *         return Promise.reject();\n   *       }\n   *       return response.blob();\n   *     })\n   *     .then((blob) => {\n   *       const imageUrl = URL.createObjectURL(blob);\n   *       image.src = imageUrl;\n   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);\n   *     })\n   *     .catch(() => tile.setState(3)); // error\n   * });\n   * ```\n   *\n   * @api\n   */\n  load() {\n    if (this.state == TileState.ERROR) {\n      this.state = TileState.IDLE;\n      this.image_ = new Image();\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      this.tileLoadFunction_(this, this.src_);\n      this.unlisten_ = listenImage(\n        this.image_,\n        this.handleImageLoad_.bind(this),\n        this.handleImageError_.bind(this)\n      );\n    }\n  }\n\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  unlistenImage_() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  }\n}\n\n/**\n * Get a 1-pixel blank image.\n * @return {HTMLCanvasElement} Blank image.\n */\nfunction getBlankImage() {\n  const ctx = createCanvasContext2D(1, 1);\n  ctx.fillStyle = 'rgba(0,0,0,0)';\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\n\nexport default ImageTile;\n", "/**\n * @module ol/TileRange\n */\n\n/**\n * A representation of a contiguous block of tiles.  A tile range is specified\n * by its min/max tile coordinates and is inclusive of coordinates.\n */\nclass TileRange {\n  /**\n   * @param {number} minX Minimum X.\n   * @param {number} maxX Maximum X.\n   * @param {number} minY Minimum Y.\n   * @param {number} maxY Maximum Y.\n   */\n  constructor(minX, maxX, minY, maxY) {\n    /**\n     * @type {number}\n     */\n    this.minX = minX;\n\n    /**\n     * @type {number}\n     */\n    this.maxX = maxX;\n\n    /**\n     * @type {number}\n     */\n    this.minY = minY;\n\n    /**\n     * @type {number}\n     */\n    this.maxY = maxY;\n  }\n\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {boolean} Contains tile coordinate.\n   */\n  contains(tileCoord) {\n    return this.containsXY(tileCoord[1], tileCoord[2]);\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Contains.\n   */\n  containsTileRange(tileRange) {\n    return (\n      this.minX <= tileRange.minX &&\n      tileRange.maxX <= this.maxX &&\n      this.minY <= tileRange.minY &&\n      tileRange.maxY <= this.maxY\n    );\n  }\n\n  /**\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @return {boolean} Contains coordinate.\n   */\n  containsXY(x, y) {\n    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Equals.\n   */\n  equals(tileRange) {\n    return (\n      this.minX == tileRange.minX &&\n      this.minY == tileRange.minY &&\n      this.maxX == tileRange.maxX &&\n      this.maxY == tileRange.maxY\n    );\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   */\n  extend(tileRange) {\n    if (tileRange.minX < this.minX) {\n      this.minX = tileRange.minX;\n    }\n    if (tileRange.maxX > this.maxX) {\n      this.maxX = tileRange.maxX;\n    }\n    if (tileRange.minY < this.minY) {\n      this.minY = tileRange.minY;\n    }\n    if (tileRange.maxY > this.maxY) {\n      this.maxY = tileRange.maxY;\n    }\n  }\n\n  /**\n   * @return {number} Height.\n   */\n  getHeight() {\n    return this.maxY - this.minY + 1;\n  }\n\n  /**\n   * @return {import(\"./size.js\").Size} Size.\n   */\n  getSize() {\n    return [this.getWidth(), this.getHeight()];\n  }\n\n  /**\n   * @return {number} Width.\n   */\n  getWidth() {\n    return this.maxX - this.minX + 1;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Intersects.\n   */\n  intersects(tileRange) {\n    return (\n      this.minX <= tileRange.maxX &&\n      this.maxX >= tileRange.minX &&\n      this.minY <= tileRange.maxY &&\n      this.maxY >= tileRange.minY\n    );\n  }\n}\n\n/**\n * @param {number} minX Minimum X.\n * @param {number} maxX Maximum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxY Maximum Y.\n * @param {TileRange} [tileRange] TileRange.\n * @return {TileRange} Tile range.\n */\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\n  if (tileRange !== undefined) {\n    tileRange.minX = minX;\n    tileRange.maxX = maxX;\n    tileRange.minY = minY;\n    tileRange.maxY = maxY;\n    return tileRange;\n  }\n  return new TileRange(minX, maxX, minY, maxY);\n}\n\nexport default TileRange;\n"],
  "mappings": "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",
  "names": []
}
